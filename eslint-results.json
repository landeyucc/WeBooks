[{"filePath":"I:\\Gitweb\\webooks\\app\\admin\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\auth\\init\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\auth\\login\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\bookmarks\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserIdFromRequest' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPublicUserId' is defined but never used.","line":4,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getUserIdFromRequest } from '@/lib/auth'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 更新书签\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('PUT bookmark - User ID:', userId)\n\n    const { title, url, description, iconUrl, folderId } = await request.json()\n\n    // 查找并验证书签所有权\n    const existingBookmark = await prisma.bookmark.findUnique({\n      where: { id: params.id }\n    })\n\n    // 验证书签所有权\n    if (!existingBookmark || existingBookmark.userId !== userId) {\n      return NextResponse.json(\n        { error: '书签不存在或无权限' },\n        { status: 404 }\n      )\n    }\n\n    const bookmark = await prisma.bookmark.update({\n      where: {\n        id: params.id\n      },\n      data: {\n        title,\n        url,\n        description,\n        iconUrl,\n        folderId\n      },\n      include: {\n        folder: {\n          select: {\n            id: true,\n            name: true\n          }\n        },\n        space: {\n          select: {\n            id: true,\n            name: true\n          }\n        }\n      }\n    })\n\n    return NextResponse.json({ bookmark })\n  } catch (error) {\n    console.error('更新书签错误:', error)\n    return NextResponse.json(\n      { error: '更新书签失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 删除书签\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('DELETE bookmark - User ID:', userId)\n\n    // 查找并验证书签所有权\n    const bookmark = await prisma.bookmark.findUnique({\n      where: { id: params.id }\n    })\n\n    // 验证书签所有权\n    if (!bookmark || bookmark.userId !== userId) {\n      return NextResponse.json(\n        { error: '书签不存在或无权限' },\n        { status: 404 }\n      )\n    }\n\n    await prisma.bookmark.delete({\n      where: {\n        id: params.id\n      }\n    })\n\n    // 更新文件夹的书签计数\n    if (bookmark?.folderId) {\n      await prisma.folder.update({\n        where: { id: bookmark.folderId },\n        data: {\n          bookmarkCount: {\n            decrement: 1\n          }\n        }\n      })\n    }\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('删除书签错误:', error)\n    return NextResponse.json(\n      { error: '删除书签失败' },\n      { status: 500 }\n    )\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\bookmarks\\export\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPublicUserId' is defined but never used.","line":3,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'format' is assigned a value but never used.","line":27,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[814,817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[814,817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2001,2004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2001,2004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2420,2423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2420,2423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2452,2455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2452,2455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3510,3513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3510,3513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 导出书签\nexport async function GET(request: NextRequest) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('GET bookmarks export - User ID:', userId)\n\n    const { searchParams } = new URL(request.url)\n    const spaceId = searchParams.get('spaceId')\n    const folderId = searchParams.get('folderId')\n    const format = searchParams.get('format') || 'html'\n\n    const where: any = { userId }\n    \n    if (spaceId) {\n      where.spaceId = spaceId\n    }\n    \n    if (folderId) {\n      where.folderId = folderId\n    }\n\n    // 获取书签数据\n    const bookmarks = await prisma.bookmark.findMany({\n      where,\n      orderBy: [\n        { folderId: 'asc' },\n        { createdAt: 'desc' }\n      ],\n      include: {\n        folder: {\n          select: {\n            name: true\n          }\n        }\n      }\n    })\n\n    if (bookmarks.length === 0) {\n      return NextResponse.json(\n        { error: '没有找到可导出的书签' },\n        { status: 404 }\n      )\n    }\n\n    // 生成HTML书签文件\n    const html = generateBookmarkHtml(bookmarks)\n\n    // 返回文件下载\n    const filename = `Webooks_bookmarks_export_${new Date().toISOString().split('T')[0]}.html`\n    \n    return new NextResponse(html, {\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'Content-Disposition': `attachment; filename=\"${filename}\"`,\n        'Content-Length': html.length.toString()\n      }\n    })\n  } catch (error) {\n    console.error('导出书签错误:', error)\n    return NextResponse.json(\n      { error: '导出书签失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 生成HTML书签文件内容\nfunction generateBookmarkHtml(bookmarks: any[]): string {\n  const now = Math.floor(Date.now() / 1000)\n  \n  let html = `<!DOCTYPE NETSCAPE-Bookmark-file-1>\n<!-- This is an automatically generated file.\n     It will be read and overwritten.\n     DO NOT EDIT! -->\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\n<TITLE>Webooks Bookmarks Export</TITLE>\n<H1>Webooks Bookmarks Export</H1>\n<DL><p>\n`\n\n  // 按文件夹分组\n  const folders = new Map<string, any[]>()\n  const rootBookmarks: any[] = []\n  \n  bookmarks.forEach(bookmark => {\n    if (bookmark.folderId && bookmark.folder) {\n      const folderName = bookmark.folder.name\n      if (!folders.has(folderName)) {\n        folders.set(folderName, [])\n      }\n      folders.get(folderName)!.push(bookmark)\n    } else {\n      rootBookmarks.push(bookmark)\n    }\n  })\n\n  // 生成根目录书签\n  if (rootBookmarks.length > 0) {\n    html += `    <DT><H3 ADD_DATE=\"${now}\" LAST_MODIFIED=\"${now}\">根目录</H3>\\n`\n    html += `    <DL><p>\\n`\n    \n    rootBookmarks.forEach(bookmark => {\n      html += generateBookmarkEntry(bookmark, now)\n    })\n    \n    html += `    </DL><p>\\n`\n  }\n\n  // 生成文件夹书签\n  folders.forEach((folderBookmarks, folderName) => {\n    html += `    <DT><H3 ADD_DATE=\"${now}\" LAST_MODIFIED=\"${now}\">${escapeHtml(folderName)}</H3>\\n`\n    html += `    <DL><p>\\n`\n    \n    folderBookmarks.forEach(bookmark => {\n      html += generateBookmarkEntry(bookmark, now)\n    })\n    \n    html += `    </DL><p>\\n`\n  })\n\n  html += `</DL><p>\\n`\n\n  return html\n}\n\n// 生成单个书签条目\nfunction generateBookmarkEntry(bookmark: any, timestamp: number): string {\n  const title = escapeHtml(bookmark.title || '未命名书签')\n  const url = escapeHtml(bookmark.url)\n  const addDate = bookmark.createdAt ? Math.floor(new Date(bookmark.createdAt).getTime() / 1000) : timestamp\n  \n  let entry = `        <DT><A HREF=\"${url}\" ADD_DATE=\"${addDate}\"`\n  \n  // 添加图标（如果有）\n  if (bookmark.iconUrl && bookmark.iconUrl.startsWith('data:')) {\n    entry += ` ICON=\"${bookmark.iconUrl}\"`\n  }\n  \n  entry += `>${title}</A>\\n`\n  \n  return entry\n}\n\n// HTML转义\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n}","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\bookmarks\\import\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPublicUserId' is defined but never used.","line":3,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'folders' is assigned a value but never used.","line":116,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createdBookmark' is assigned a value but never used.","line":165,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":165,"endColumn":30}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\nimport { JSDOM } from 'jsdom'\n\ninterface ParsedBookmark {\n  title: string\n  url: string\n  iconUrl?: string\n  addDate?: number\n}\n\ninterface ParsedFolder {\n  name: string\n  addDate?: number\n  lastModified?: number\n  personalToolbarFolder?: boolean\n}\n\n// 解析HTML书签文件\nfunction parseBookmarkHtml(html: string): { bookmarks: ParsedBookmark[], folders: ParsedFolder[] } {\n  const dom = new JSDOM(html)\n  const document = dom.window.document\n  \n  const bookmarks: ParsedBookmark[] = []\n  const folders: ParsedFolder[] = []\n  \n  // 查找所有DT元素\n  const dtElements = document.querySelectorAll('DT')\n  \n  dtElements.forEach((dt: Element) => {\n    const h3 = dt.querySelector('H3')\n    const a = dt.querySelector('A')\n    \n    if (h3) {\n      // 这是一个文件夹\n      const folder: ParsedFolder = {\n        name: h3.textContent || '未命名文件夹',\n        addDate: h3.getAttribute('ADD_DATE') ? parseInt(h3.getAttribute('ADD_DATE')!) : undefined,\n        lastModified: h3.getAttribute('LAST_MODIFIED') ? parseInt(h3.getAttribute('LAST_MODIFIED')!) : undefined,\n        personalToolbarFolder: h3.getAttribute('PERSONAL_TOOLBAR_FOLDER') === 'true'\n      }\n      folders.push(folder)\n    } else if (a) {\n      // 这是一个书签\n      const bookmark: ParsedBookmark = {\n        title: a.textContent || '未命名书签',\n        url: a.getAttribute('HREF') || '',\n        iconUrl: a.getAttribute('ICON') || undefined,\n        addDate: a.getAttribute('ADD_DATE') ? parseInt(a.getAttribute('ADD_DATE')!) : undefined\n      }\n      if (bookmark.url) {\n        bookmarks.push(bookmark)\n      }\n    }\n  })\n  \n  return { bookmarks, folders }\n}\n\n// 获取网站图标\nasync function fetchFavicon(url: string): Promise<string | null> {\n  try {\n    const response = await fetch(`/api/favicon?url=${encodeURIComponent(url)}`)\n    if (response.ok) {\n      const data = await response.json()\n      return data.favicon || null\n    }\n  } catch (error) {\n    console.error('获取图标失败:', error)\n  }\n  return null\n}\n\n// 导入书签\nexport async function POST(request: NextRequest) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('POST bookmarks import - User ID:', userId)\n\n    const formData = await request.formData()\n    const file = formData.get('file') as File\n    \n    if (!file) {\n      return NextResponse.json(\n        { error: '请选择要导入的HTML文件' },\n        { status: 400 }\n      )\n    }\n\n    // 检查文件类型\n    if (!file.name.toLowerCase().endsWith('.html')) {\n      return NextResponse.json(\n        { error: '请选择HTML格式的书签文件' },\n        { status: 400 }\n      )\n    }\n\n    // 读取文件内容\n    const html = await file.text()\n    \n    // 解析HTML书签文件\n    const { bookmarks, folders } = parseBookmarkHtml(html)\n    \n    if (bookmarks.length === 0) {\n      return NextResponse.json(\n        { error: '文件中未找到有效的书签数据' },\n        { status: 400 }\n      )\n    }\n\n    // 创建以当前时间戳命名的文件夹\n    const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\\..+/, '')\n    const folderName = `input_${timestamp}`\n    \n    // 获取默认空间\n    const systemConfig = await prisma.systemConfig.findFirst()\n    if (!systemConfig || !systemConfig.defaultSpaceId) {\n      return NextResponse.json(\n        { error: '系统未配置默认空间' },\n        { status: 400 }\n      )\n    }\n\n    // 创建文件夹\n    const folder = await prisma.folder.create({\n      data: {\n        name: folderName,\n        description: `从书签文件导入的文件夹 - ${file.name}`,\n        userId,\n        spaceId: systemConfig.defaultSpaceId\n      }\n    })\n\n    console.log(`创建文件夹: ${folderName} (ID: ${folder.id})`)\n\n    let successCount = 0\n    let errorCount = 0\n    const errors: string[] = []\n\n    // 批量创建书签\n    for (const bookmark of bookmarks) {\n      try {\n        let iconUrl = bookmark.iconUrl\n        \n        // 如果没有图标，尝试获取\n        if (!iconUrl) {\n          const fetchedIcon = await fetchFavicon(bookmark.url)\n          iconUrl = fetchedIcon || undefined\n        }\n\n        const createdBookmark = await prisma.bookmark.create({\n          data: {\n            title: bookmark.title,\n            url: bookmark.url,\n            description: `从书签文件导入 - ${file.name}`,\n            iconUrl: iconUrl || undefined,\n            userId,\n            spaceId: systemConfig.defaultSpaceId,\n            folderId: folder.id\n          }\n        })\n\n        successCount++\n        console.log(`导入书签: ${bookmark.title} (${bookmark.url})`)\n      } catch (error) {\n        errorCount++\n        const errorMsg = `导入书签失败: ${bookmark.title} (${bookmark.url}) - ${error}`\n        console.error(errorMsg)\n        errors.push(errorMsg)\n      }\n    }\n\n    // 更新文件夹的书签计数\n    await prisma.folder.update({\n      where: { id: folder.id },\n      data: {\n        bookmarkCount: successCount\n      }\n    })\n\n    const result: {\n      success: boolean\n      folderId: string\n      folderName: string\n      total: number\n      successCount: number\n      errorCount: number\n      message: string | undefined\n      errors?: string[]\n    } = {\n      success: true,\n      folderId: folder.id,\n      folderName,\n      total: bookmarks.length,\n      successCount,\n      errorCount,\n      message: `成功导入 ${successCount} 个书签，失败 ${errorCount} 个`\n    }\n\n    if (errors.length > 0) {\n      result['errors'] = errors\n    }\n\n    return NextResponse.json(result)\n  } catch (error) {\n    console.error('导入书签错误:', error)\n    return NextResponse.json(\n      { error: '导入书签失败' },\n      { status: 500 }\n    )\n  }\n}","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\bookmarks\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserIdFromRequest' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[614,617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[614,617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getUserIdFromRequest } from '@/lib/auth'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 获取书签\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const spaceId = searchParams.get('spaceId')\n    const folderId = searchParams.get('folderId')\n    const search = searchParams.get('search')\n\n    const targetUserId = await getPublicUserId(request)\n    console.log('GET bookmarks - User ID:', targetUserId)\n\n    const where: any = { userId: targetUserId }\n    \n    if (spaceId) {\n      where.spaceId = spaceId\n    }\n    \n    if (folderId) {\n      where.folderId = folderId\n    }\n\n    if (search) {\n      where.OR = [\n        { title: { contains: search, mode: 'insensitive' } },\n        { description: { contains: search, mode: 'insensitive' } },\n        { url: { contains: search, mode: 'insensitive' } }\n      ]\n    }\n\n    const bookmarks = await prisma.bookmark.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      include: {\n        folder: {\n          select: {\n            id: true,\n            name: true\n          }\n        },\n        space: {\n          select: {\n            id: true,\n            name: true\n          }\n        }\n      }\n    })\n\n    return NextResponse.json({ bookmarks })\n  } catch (error) {\n    console.error('获取书签错误:', error)\n    return NextResponse.json(\n      { error: '获取书签失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 创建书签\nexport async function POST(request: NextRequest) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('POST bookmarks - User ID:', userId)\n\n    const { title, url, description, iconUrl, spaceId, folderId } = await request.json()\n\n    // 用户现在需要使用独立的抓取API手动获取元数据\n    const bookmark = await prisma.bookmark.create({\n      data: {\n        title,\n        url,\n        description,\n        iconUrl,\n        spaceId,\n        folderId,\n        userId\n      },\n      include: {\n        folder: {\n          select: {\n            id: true,\n            name: true\n          }\n        },\n        space: {\n          select: {\n            id: true,\n            name: true\n          }\n        }\n      }\n    })\n\n    // 更新文件夹的书签计数\n    if (folderId) {\n      await prisma.folder.update({\n        where: { id: folderId },\n        data: {\n          bookmarkCount: {\n            increment: 1\n          }\n        }\n      })\n    }\n\n    return NextResponse.json({ bookmark })\n  } catch (error) {\n    console.error('创建书签错误:', error)\n    return NextResponse.json(\n      { error: '创建书签失败' },\n      { status: 500 }\n    )\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\extension\\api-key\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\extension\\bookmarks\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\folders\\[id]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\folders\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserIdFromRequest' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[546,549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[546,549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getUserIdFromRequest } from '@/lib/auth'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 获取文件夹\nexport async function GET(request: NextRequest) {\n  try {\n    // 使用公共用户访问，允许未认证用户获取文件夹\n    const targetUserId = await getPublicUserId(request)\n    console.log('GET folders - User ID:', targetUserId)\n\n    const { searchParams } = new URL(request.url)\n    const spaceId = searchParams.get('spaceId')\n\n    const where: any = { userId: targetUserId }\n    if (spaceId) {\n      where.spaceId = spaceId\n    }\n\n    const folders = await prisma.folder.findMany({\n      where,\n      orderBy: { createdAt: 'asc' },\n      include: {\n        _count: {\n          select: {\n            bookmarks: true,\n            childFolders: true\n          }\n        }\n      }\n    })\n\n    // 转换数据格式以匹配前端期望\n    const formattedFolders = folders.map(folder => ({\n      ...folder,\n      bookmarkCount: folder._count.bookmarks\n    }))\n\n    return NextResponse.json({ folders: formattedFolders })\n  } catch (error) {\n    console.error('获取文件夹错误:', error)\n    return NextResponse.json(\n      { error: '获取文件夹失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 创建文件夹\nexport async function POST(request: NextRequest) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    // 如果有response错误，直接返回\n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n\n    console.log('POST folders - User ID:', userId)\n\n    const { name, description, iconUrl, spaceId, parentFolderId } = await request.json()\n\n    const folder = await prisma.folder.create({\n      data: {\n        name,\n        description,\n        iconUrl,\n        spaceId,\n        parentFolderId,\n        userId\n      }\n    })\n\n    return NextResponse.json({ folder })\n  } catch (error) {\n    console.error('创建文件夹错误:', error)\n    return NextResponse.json(\n      { error: '创建文件夹失败' },\n      { status: 500 }\n    )\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\scrape\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\spaces\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserIdFromRequest' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPublicUserId' is defined but never used.","line":4,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1242,1245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1242,1245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getUserIdFromRequest } from '@/lib/auth'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 更新空间\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('PUT space - User ID:', userId)\n\n    const { name, description, iconUrl, systemCardUrl } = await request.json()\n\n    // 查找并验证书签所有权\n    const existingSpace = await prisma.space.findUnique({\n      where: { id: params.id }\n    })\n\n    // 验证书签所有权\n    if (!existingSpace || existingSpace.userId !== userId) {\n      return NextResponse.json(\n        { error: '空间不存在或无权限' },\n        { status: 404 }\n      )\n    }\n\n    const space = await prisma.space.update({\n      where: {\n        id: params.id\n      },\n      data: {\n        name,\n        description,\n        iconUrl,\n        systemCardUrl\n      } as any\n    })\n\n    return NextResponse.json({ space })\n  } catch (error) {\n    console.error('更新空间错误:', error)\n    return NextResponse.json(\n      { error: '更新空间失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 删除空间\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    \n    if (authResult.response) {\n      return authResult.response\n    }\n\n    const userId = authResult.userId\n    if (!userId) {\n      return NextResponse.json(\n        { error: '认证失败' },\n        { status: 401 }\n      )\n    }\n    \n    console.log('DELETE space - User ID:', userId)\n    console.log('Deleting space ID:', params.id)\n\n    // 首先检查空间是否存在且属于当前用户\n    const space = await prisma.space.findUnique({\n      where: {\n        id: params.id\n      },\n      include: {\n        _count: {\n          select: {\n            bookmarks: true,\n            folders: true\n          }\n        }\n      }\n    })\n\n    // 验证空间所有权\n    if (!space || space.userId !== userId) {\n      return NextResponse.json(\n        { error: '空间不存在或无权限' },\n        { status: 404 }\n      )\n    }\n\n    console.log('Found space:', space.name, 'Bookmarks:', space._count.bookmarks, 'Folders:', space._count.folders)\n\n    // 使用事务删除空间及其关联数据\n    await prisma.$transaction(async (tx) => {\n      // 先删除关联的收藏夹\n      if (space._count.folders > 0) {\n        await tx.bookmark.deleteMany({\n          where: {\n            folder: {\n              spaceId: params.id\n            }\n          }\n        })\n        \n        await tx.folder.deleteMany({\n          where: {\n            spaceId: params.id\n          }\n        })\n      }\n\n      // 删除剩余的收藏夹（不在文件夹中的）\n      await tx.bookmark.deleteMany({\n        where: {\n          spaceId: params.id\n        }\n      })\n\n      // 删除空间\n      await tx.space.delete({\n        where: {\n          id: params.id\n        }\n      })\n    })\n\n    console.log('Space deleted successfully:', params.id)\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('删除空间错误:', error)\n    return NextResponse.json(\n      { error: '删除空间失败' },\n      { status: 500 }\n    )\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\spaces\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUserIdFromRequest' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { getUserIdFromRequest } from '@/lib/auth'\nimport { getAuthenticatedUserId, getPublicUserId } from '@/lib/auth-helper'\n\n// 获取所有空间\nexport async function GET(request: NextRequest) {\n  try {\n    const targetUserId = await getPublicUserId(request)\n    console.log('GET spaces - User ID:', targetUserId)\n\n    const spaces = await prisma.space.findMany({\n      where: { userId: targetUserId },\n      orderBy: { createdAt: 'asc' },\n      include: {\n        _count: {\n          select: {\n            bookmarks: true,\n            folders: true\n          }\n        }\n      }\n    })\n\n    return NextResponse.json({ spaces })\n  } catch (error) {\n    console.error('获取空间错误:', error)\n    return NextResponse.json(\n      { error: '获取空间失败', details: String(error) },\n      { status: 500 }\n    )\n  }\n}\n\n// 创建空间（需要认证）\nexport async function POST(request: NextRequest) {\n  try {\n    const authResult = await getAuthenticatedUserId(request)\n    if (authResult.response) {\n      return authResult.response\n    }\n    \n    const userId = authResult.userId!\n    console.log('POST spaces - User ID:', userId)\n\n    const requestBody = await request.json()\n    console.log('POST spaces - Request body:', requestBody)\n    \n    const { name, description, iconUrl, systemCardUrl } = requestBody\n    \n    // 验证必填字段\n    if (!name || name.trim() === '') {\n      return NextResponse.json(\n        { error: '空间名称不能为空' },\n        { status: 400 }\n      )\n    }\n\n    // 检查用户是否已经有同名的空间\n    const existingSpace = await prisma.space.findFirst({\n      where: {\n        userId: userId,\n        name: name.trim()\n      }\n    })\n    \n    if (existingSpace) {\n      return NextResponse.json(\n        { error: '已存在同名空间' },\n        { status: 400 }\n      )\n    }\n\n    const space = await prisma.space.create({\n      data: {\n        name: name.trim(),\n        description: description || null,\n        iconUrl: iconUrl || null,\n        systemCardUrl: systemCardUrl || null,\n        userId\n      }\n    })\n\n    console.log('POST spaces - Created space:', space.id)\n    return NextResponse.json({ space })\n  } catch (error) {\n    console.error('创建空间错误:', error)\n    return NextResponse.json(\n      { error: '创建空间失败', details: String(error) },\n      { status: 500 }\n    )\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\api\\system-config\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":5,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":34},{"ruleId":"prefer-const","severity":2,"message":"'user' is never reassigned. Use 'const' instead.","line":8,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":8,"endColumn":13,"fix":{"range":[199,239],"text":"const user = await prisma.user.findFirst()"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3749,3752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3749,3752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\n// 获取系统配置（单用户模式）\nexport async function GET(request: NextRequest) {\n  try {\n    // 在单用户模式下，先确保存在一个用户\n    let user = await prisma.user.findFirst()\n    if (!user) {\n      // 如果没有用户，返回空的配置\n      return NextResponse.json({\n        id: null,\n        defaultSpaceId: null,\n        defaultSpace: null,\n        // 网站设置\n        siteTitle: null,\n        faviconUrl: null,\n        seoDescription: null,\n        keywords: null,\n        createdAt: null,\n        updatedAt: null\n      })\n    }\n\n    // 在单用户模式下，获取当前用户的配置记录\n    const config = await prisma.systemConfig.findFirst({\n      where: { userId: user.id },\n      include: {\n        defaultSpace: {\n          select: {\n            id: true,\n            name: true\n          }\n        }\n      }\n    })\n\n    return NextResponse.json({\n      id: config?.id || null,\n      defaultSpaceId: config?.defaultSpaceId || null,\n      defaultSpace: config?.defaultSpace || null,\n      // 网站设置\n      siteTitle: config?.siteTitle || null,\n      faviconUrl: config?.faviconUrl || null,\n      seoDescription: config?.seoDescription || null,\n      keywords: config?.keywords || null,\n      createdAt: config?.createdAt || null,\n      updatedAt: config?.updatedAt || null\n    })\n  } catch (error) {\n    console.error('获取系统配置错误:', error)\n    return NextResponse.json(\n      { error: '获取系统配置失败' },\n      { status: 500 }\n    )\n  }\n}\n\n// 更新系统配置（单用户模式）\nexport async function PUT(request: NextRequest) {\n  try {\n    const { \n      defaultSpaceId, \n      siteTitle, \n      faviconUrl, \n      seoDescription, \n      keywords \n    } = await request.json()\n\n    // 在单用户模式下，先确保存在一个用户\n    let user = await prisma.user.findFirst()\n    if (!user) {\n      // 如果没有用户，创建一个默认用户（单用户模式）\n      user = await prisma.user.create({\n        data: {\n          username: 'admin',\n          passwordHash: 'default_hash' // 单用户模式下不需要真实密码\n        }\n      })\n    }\n\n    // 检查defaultSpaceId是否存在且属于当前用户（如果提供了的话）\n    if (defaultSpaceId) {\n      const space = await prisma.space.findUnique({\n        where: { \n          id: defaultSpaceId,\n          userId: user.id // 确保空间属于当前用户\n        }\n      })\n      \n      if (!space) {\n        return NextResponse.json(\n          { error: '指定的空间不存在或不属于当前用户' },\n          { status: 400 }\n        )\n      }\n    }\n\n    // 在单用户模式下，更新现有配置或创建新配置\n    const existingConfig = await prisma.systemConfig.findFirst({\n      where: { userId: user.id }\n    })\n    \n    let config\n    if (existingConfig) {\n      // 如果存在现有配置，更新它\n      config = await prisma.systemConfig.update({\n        where: { id: existingConfig.id },\n        data: { \n          defaultSpaceId,\n          siteTitle,\n          faviconUrl,\n          seoDescription,\n          keywords\n        },\n        include: {\n          defaultSpace: {\n            select: {\n              id: true,\n              name: true\n            }\n          }\n        }\n      })\n    } else {\n      // 如果没有现有配置，创建新配置\n      config = await prisma.systemConfig.create({\n        data: { \n          userId: user.id,\n          defaultSpaceId,\n          siteTitle,\n          faviconUrl,\n          seoDescription,\n          keywords\n        },\n        include: {\n          defaultSpace: {\n            select: {\n              id: true,\n              name: true\n            }\n          }\n        }\n      })\n    }\n\n    return NextResponse.json({\n      id: config.id,\n      defaultSpaceId: config.defaultSpaceId,\n      defaultSpace: config.defaultSpace,\n      // 网站设置\n      siteTitle: config.siteTitle,\n      faviconUrl: config.faviconUrl,\n      seoDescription: config.seoDescription,\n      keywords: config.keywords,\n      createdAt: config.createdAt,\n      updatedAt: config.updatedAt\n    })\n  } catch (error: any) {\n    console.error('更新系统配置错误:', error)\n    \n    // 如果是外键约束错误，返回更详细的错误信息\n    if (error.code === 'P2003') {\n      return NextResponse.json(\n        { error: '外键约束违反，请检查空间ID是否正确' },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: '更新系统配置失败', details: error.message },\n      { status: 500 }\n    )\n  }\n}","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\lib\\server-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\login\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\BookmarkGrid.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'fetchBookmarks'. Either include it or remove the dependency array.","line":43,"column":6,"nodeType":"ArrayExpression","endLine":43,"endColumn":62,"suggestions":[{"desc":"Update the dependencies array to be: [spaceId, folderId, searchQuery, isAuthenticated, token, fetchBookmarks]","fix":{"range":[1095,1151],"text":"[spaceId, folderId, searchQuery, isAuthenticated, token, fetchBookmarks]"}}]},{"ruleId":"@next/next/no-img-element","severity":1,"message":"Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","line":219,"column":21,"nodeType":"JSXOpeningElement","endLine":227,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useApp } from '@/contexts/AppContext'\n\ninterface Bookmark {\n  id: string\n  title: string\n  url: string\n  description: string | null\n  iconUrl: string | null\n  space: {\n    id: string\n    name: string\n  }\n  folder: {\n    id: string\n    name: string\n  } | null\n}\n\ninterface BookmarkGridProps {\n  spaceId: string | null\n  folderId: string | null\n  searchQuery: string\n}\n\nexport default function BookmarkGrid({ spaceId, folderId, searchQuery }: BookmarkGridProps) {\n  const { t, isAuthenticated, token } = useApp()\n  const [bookmarks, setBookmarks] = useState<Bookmark[]>([])\n  const [loading, setLoading] = useState(true)\n  const [hoveredBookmarkId, setHoveredBookmarkId] = useState<string | null>(null)\n  const [hoverTimeout, setHoverTimeout] = useState<NodeJS.Timeout | null>(null)\n  const [mousePosition, setMousePosition] = useState<{ x: number; y: number } | null>(null)\n  \n  // 移动端检测\n  const [isMobile, setIsMobile] = useState(false)\n\n  useEffect(() => {\n    if (isAuthenticated && token) {\n      fetchBookmarks()\n    }\n  }, [spaceId, folderId, searchQuery, isAuthenticated, token])\n\n  // 检测屏幕尺寸变化\n  useEffect(() => {\n    const checkScreenSize = () => {\n      setIsMobile(window.innerWidth < 768)\n    }\n\n    // 初始检查\n    checkScreenSize()\n\n    // 监听窗口大小变化\n    window.addEventListener('resize', checkScreenSize)\n    \n    return () => window.removeEventListener('resize', checkScreenSize)\n  }, [])\n\n  // 计算智能定位（防止超出屏幕边界）\n  const calculateTooltipPosition = (mouseX: number, mouseY: number) => {\n    const tooltipWidth = 320 // 提示框宽度 (w-80 = 320px)\n    const tooltipHeight = 200 // 提示框估计高度\n    const margin = 8 // 边缘安全距离\n    const gap = 8 // 与光标之间的距离\n    \n    // 默认显示在下方\n    let left = mouseX\n    let top = mouseY + gap\n    \n    // 垂直边界检查：如果下方空间不够，则显示在上方\n    if (top + tooltipHeight > window.innerHeight - margin) {\n      top = mouseY - tooltipHeight - gap\n    }\n    \n    // 水平边界检查\n    if (left + tooltipWidth > window.innerWidth - margin) {\n      left = mouseX - tooltipWidth\n    }\n    \n    // 确保不超出左边缘\n    if (left < margin) {\n      left = margin\n    }\n    \n    // 确保不超出上边缘（只在上方显示时生效）\n    if (top < margin && top < mouseY) {\n      top = mouseY + gap // 如果上方放不下，则放回下方\n    }\n    \n    return { left, top }\n  }\n\n  // 处理鼠标悬浮开始\n  const handleMouseEnter = (e: React.MouseEvent, bookmarkId: string) => {\n    // 移动端禁用详细信息描述框\n    if (isMobile) return\n    \n    if (hoverTimeout) {\n      clearTimeout(hoverTimeout)\n    }\n    \n    // 获取真实鼠标光标位置\n    const mouseX = e.clientX\n    const mouseY = e.clientY\n    \n    setMousePosition({ x: mouseX, y: mouseY })\n    \n    const timeout = setTimeout(() => {\n      setHoveredBookmarkId(bookmarkId)\n    }, 500) // 1秒后显示\n    setHoverTimeout(timeout)\n  }\n\n  // 处理鼠标移动 - 实时更新光标位置\n  const handleMouseMove = (e: React.MouseEvent) => {\n    // 移动端禁用详细信息描述框\n    if (isMobile) return\n    \n    // 实时更新鼠标光标位置\n    const mouseX = e.clientX\n    const mouseY = e.clientY\n    \n    setMousePosition({ x: mouseX, y: mouseY })\n  }\n\n  // 处理鼠标离开\n  const handleMouseLeave = () => {\n    // 移动端禁用详细信息描述框\n    if (isMobile) return\n    \n    if (hoverTimeout) {\n      clearTimeout(hoverTimeout)\n      setHoverTimeout(null)\n    }\n    setHoveredBookmarkId(null)\n    setMousePosition(null)\n  }\n\n  const fetchBookmarks = async () => {\n    if (!isAuthenticated || !token) {\n      console.log('BookmarkGrid: 用户未认证，跳过获取书签')\n      return\n    }\n    \n    setLoading(true)\n    try {\n      const params = new URLSearchParams()\n      if (spaceId) params.append('spaceId', spaceId)\n      if (folderId) params.append('folderId', folderId)\n      if (searchQuery) params.append('search', searchQuery)\n\n      const response = await fetch(`/api/bookmarks?${params.toString()}`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n        },\n      })\n      const data = await response.json()\n      setBookmarks(data.bookmarks || [])\n    } catch (error) {\n      console.error(t('fetchBookmarksFailed'), error)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center h-full\">\n        <div className=\"text-lg text-gray-500\">{t('loading')}</div>\n      </div>\n    )\n  }\n\n  if (bookmarks.length === 0) {\n    return (\n      <div className=\"flex items-center justify-center h-full\">\n        <div className=\"text-center text-gray-500\">\n          <svg\n            className=\"w-16 h-16 mx-auto mb-4 text-gray-300\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z\"\n            />\n          </svg>\n          <p>{t('noBookmarks')}</p>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\">\n        {bookmarks.map((bookmark) => (\n          <div\n            key={bookmark.id}\n            className=\"relative\"\n            onMouseEnter={(e) => handleMouseEnter(e, bookmark.id)}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n          >\n            <a\n              href={bookmark.url}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"card p-4 block hover:scale-105 transition-transform duration-200\"\n            >\n              <div className=\"flex items-start gap-3\">\n                {/* 图标 */}\n                <div className=\"flex-shrink-0 w-12 h-12 rounded-lg bg-gray-100 dark:bg-gray-700 flex items-center justify-center overflow-hidden\">\n                  {bookmark.iconUrl ? (\n                    <img\n                      src={bookmark.iconUrl}\n                      alt={bookmark.title}\n                      className=\"w-8 h-8 object-contain\"\n                      onError={(e) => {\n                        e.currentTarget.style.display = 'none'\n                        e.currentTarget.nextElementSibling!.classList.remove('hidden')\n                      }}\n                    />\n                  ) : null}\n                  <svg\n                    className={`w-6 h-6 text-gray-400 ${bookmark.iconUrl ? 'hidden' : ''}`}\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    viewBox=\"0 0 24 24\"\n                  >\n                    <path\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      strokeWidth={2}\n                      d=\"M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z\"\n                    />\n                  </svg>\n                </div>\n\n                {/* 内容 */}\n                <div className=\"flex-1 min-w-0\">\n                  <h3 className=\"font-medium text-gray-900 dark:text-gray-100 truncate mb-1\">\n                    {bookmark.title}\n                  </h3>\n                  {bookmark.description && (\n                    <p className=\"text-sm text-gray-500 dark:text-gray-400 line-clamp-2 mb-2\">\n                      {bookmark.description}\n                    </p>\n                  )}\n                  {/* 显示链接域名 */}\n                  <div className=\"text-xs text-blue-600 dark:text-blue-400 truncate flex items-center\">\n                    <i className=\"fas fa-link mr-1\"></i>\n                    {new URL(bookmark.url).hostname}\n                  </div>\n                </div>\n              </div>\n            </a>\n\n            {/* 自定义悬浮提示框 - 跟随鼠标位置定位 */}\n            {hoveredBookmarkId === bookmark.id && mousePosition && (\n              <div \n                className=\"fixed z-[9999] w-80 bg-white dark:bg-gray-800 text-gray-900 dark:text-white p-4 rounded-lg shadow-xl border border-gray-200 dark:border-gray-600\"\n                style={{\n                  left: calculateTooltipPosition(mousePosition.x, mousePosition.y).left,\n                  top: calculateTooltipPosition(mousePosition.x, mousePosition.y).top,\n                }}\n              >\n                <div className=\"space-y-2\">\n                  <h4 className=\"font-medium text-sm text-gray-900 dark:text-white\">{bookmark.title}</h4>\n                  {bookmark.description && (\n                    <p className=\"text-xs text-gray-600 dark:text-gray-300\">{bookmark.description}</p>\n                  )}\n                  <div className=\"flex items-center gap-2 text-xs\">\n                    <i className=\"fas fa-link text-blue-500 dark:text-blue-400\"></i>\n                    <span className=\"text-blue-500 dark:text-blue-400 break-all\">{bookmark.url}</span>\n                  </div>\n                  <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                    {t('tooltipInfoDisplay')}\n                  </div>\n                </div>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\HomePage.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'isSidebarOpen'. Either include it or remove the dependency array.","line":49,"column":6,"nodeType":"ArrayExpression","endLine":49,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [isSidebarOpen]","fix":{"range":[1546,1548],"text":"[isSidebarOpen]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'checkInitStatus'. Either include it or remove the dependency array.","line":53,"column":6,"nodeType":"ArrayExpression","endLine":53,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [checkInitStatus]","fix":{"range":[1598,1600],"text":"[checkInitStatus]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'selectedSpaceId' and 't'. Either include them or remove the dependency array.","line":173,"column":6,"nodeType":"ArrayExpression","endLine":173,"endColumn":70,"suggestions":[{"desc":"Update the dependencies array to be: [checkingInit, loading, needsInit, isAuthenticated, token, user, selectedSpaceId, t]","fix":{"range":[5187,5251],"text":"[checkingInit, loading, needsInit, isAuthenticated, token, user, selectedSpaceId, t]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport { useApp } from '@/contexts/AppContext'\nimport Sidebar from '@/components/Sidebar'\nimport Header from '@/components/Header'\nimport BookmarkGrid from '@/components/BookmarkGrid'\nimport InitModal from '@/components/InitModal'\n\nexport default function HomePage() {\n  const { token, loading, isAuthenticated, user, t } = useApp()\n  const [needsInit, setNeedsInit] = useState(false)\n  const [checkingInit, setCheckingInit] = useState(true)\n  const [selectedSpaceId, setSelectedSpaceId] = useState<string | null>(null)\n  const [selectedFolderId, setSelectedFolderId] = useState<string | null>(null)\n  const [searchQuery, setSearchQuery] = useState('')\n  const [searchMode, setSearchMode] = useState<'bookmarks' | 'engine'>('bookmarks')\n  // 控制侧边栏显示状态 - 移动端默认关闭，桌面端默认开启\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false)\n\n  // 控制搜索栏显示状态 - 移动端默认关闭\n  const [isSearchOpen, setIsSearchOpen] = useState(false)\n\n  // 响应式处理\n  const [isMobile, setIsMobile] = useState(false)\n  \n  // 跟踪默认空间初始化状态\n  const defaultSpaceInit = useRef(false)\n\n  // 检测屏幕尺寸变化\n  useEffect(() => {\n    const checkScreenSize = () => {\n      const mobile = window.innerWidth < 768\n      setIsMobile(mobile)\n      \n      // 在桌面端，默认打开侧边栏\n      if (!mobile && !isSidebarOpen) {\n        setIsSidebarOpen(true)\n      }\n    }\n\n    // 初始检查\n    checkScreenSize()\n\n    // 监听窗口大小变化\n    window.addEventListener('resize', checkScreenSize)\n    \n    return () => window.removeEventListener('resize', checkScreenSize)\n  }, [])\n\n  useEffect(() => {\n    checkInitStatus()\n  }, [])\n\n  // 设置默认空间逻辑 - 优先使用系统配置的默认空间\n  useEffect(() => {\n    let isMounted = true // 添加组件挂载状态检查\n    \n    const setDefaultSpace = async () => {\n      // 重置挂载状态，允许重新执行\n      const mounted = { current: true }\n      \n      try {\n        console.log('开始设置默认空间，认证状态:', { \n          isAuthenticated, \n          token: !!token, \n          user: !!user \n        })\n        \n        // 确保用户完全认证（token和user都存在）\n        if (!isAuthenticated || !token || !user) {\n          console.log('用户未完全认证，等待认证完成:', { \n            isAuthenticated, \n            hasToken: !!token, \n            hasUser: !!user \n          })\n          return\n        }\n        \n        // 确保还没有设置默认空间\n        if (selectedSpaceId) {\n          console.log('默认空间已设置，跳过设置:', selectedSpaceId)\n          return\n        }\n        \n        console.log('开始获取默认空间设置...')\n        \n        // 优先从系统配置获取默认空间\n        const configResponse = await fetch('/api/system-config', {\n          headers: {\n            'Authorization': `Bearer ${token}`,\n          },\n        })\n\n        if (configResponse.ok) {\n          const config = await configResponse.json()\n          console.log('获取到的系统配置:', config)\n          if (config.defaultSpaceId && mounted.current) {\n            console.log('使用系统默认空间:', config.defaultSpaceId)\n            setSelectedSpaceId(config.defaultSpaceId)\n            return\n          } else {\n            console.log('未找到系统默认空间，将选择第一个可用空间')\n          }\n        } else {\n          console.log('获取系统配置失败，状态码:', configResponse.status)\n        }\n\n        // 如果没有默认空间或系统配置获取失败，获取第一个可用空间作为备用\n        if (!selectedSpaceId && mounted.current) {\n          console.log('开始获取第一个可用空间...')\n          const spacesResponse = await fetch('/api/spaces', {\n            headers: {\n              'Authorization': `Bearer ${token}`,\n            },\n          })\n\n          if (spacesResponse.ok) {\n            const spacesData = await spacesResponse.json()\n            // 处理API返回的格式 {spaces: [...]} 或直接数组格式\n            let spaces = []\n            if (Array.isArray(spacesData)) {\n              spaces = spacesData\n            } else if (spacesData.spaces && Array.isArray(spacesData.spaces)) {\n              spaces = spacesData.spaces\n            } else if (spacesData.data && Array.isArray(spacesData.data)) {\n              spaces = spacesData.data\n            }\n            \n            console.log('获取到的空间数据:', spaces)\n            if (spaces.length > 0 && mounted.current) {\n              console.log('使用第一个可用空间作为默认空间:', spaces[0].id)\n              setSelectedSpaceId(spaces[0].id)\n            }\n          } else {\n            console.log('获取空间数据失败，状态码:', spacesResponse.status)\n          }\n        }\n      } catch (error) {\n        if (mounted.current) {\n          console.error(t('setDefaultSpaceFailed'), error)\n        }\n      }\n    }\n\n    // 只有在用户完全认证完成且未初始化的情况下才设置默认空间\n    console.log('HomePage useEffect:', { \n      checkingInit, \n      loading, \n      needsInit, \n      isAuthenticated, \n      hasToken: !!token, \n      hasUser: !!user,\n      selectedSpaceId,\n      defaultSpaceInit: defaultSpaceInit.current // 添加初始化状态检查\n    })\n    \n    // 等待所有初始状态都完成后再设置默认空间，且只执行一次\n    if (!checkingInit && !loading && !needsInit && isAuthenticated && token && user && !selectedSpaceId && !defaultSpaceInit.current) {\n      console.log('开始执行默认空间设置...')\n      defaultSpaceInit.current = true // 标记已开始初始化\n      // 添加一个小延迟，确保AppContext完全恢复状态\n      const timeoutId = setTimeout(() => {\n        if (isMounted) {\n          setDefaultSpace()\n        }\n      }, 200)\n      return () => {\n        isMounted = false\n        clearTimeout(timeoutId)\n      }\n    }\n  }, [checkingInit, loading, needsInit, isAuthenticated, token, user])\n\n  const checkInitStatus = async () => {\n    try {\n      const response = await fetch('/api/auth/init')\n      const data = await response.json()\n      setNeedsInit(data.needsInit)\n    } catch (error) {\n      console.error(t('checkInitFailed'), error)\n    } finally {\n      setCheckingInit(false)\n    }\n  }\n\n  if (checkingInit || loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-lg\">{t('loading')}</div>\n      </div>\n    )\n  }\n\n  if (needsInit) {\n    return <InitModal onComplete={() => setNeedsInit(false)} />\n  }\n\n  return (\n    <div className=\"flex h-screen overflow-hidden bg-gray-50 dark:bg-gray-900\">\n      {/* 侧边栏 - 响应式布局 */}\n      <div className={`\n        ${isMobile \n          ? `fixed inset-y-0 left-0 z-50 w-80 transform transition-transform duration-300 ease-in-out ${\n              isSidebarOpen ? 'translate-x-0' : '-translate-x-full'\n            }`\n          : `relative ${isSidebarOpen ? 'w-80' : 'w-0'} transition-all duration-300 ease-in-out overflow-hidden`\n        }\n      `}>\n        <Sidebar\n          isOpen={isMobile ? true : isSidebarOpen}\n          selectedSpaceId={selectedSpaceId}\n          selectedFolderId={selectedFolderId}\n          onSelectSpace={setSelectedSpaceId}\n          onSelectFolder={setSelectedFolderId}\n          onToggle={() => setIsSidebarOpen(!isSidebarOpen)}\n        />\n      </div>\n\n      {/* 移动端遮罩层 */}\n      {isMobile && isSidebarOpen && (\n        <div \n          className=\"fixed inset-0 bg-black bg-opacity-50 z-40\"\n          onClick={(e) => {\n            e.stopPropagation()\n            setIsSidebarOpen(false)\n          }}\n        />\n      )}\n\n      {/* 主内容区 */}\n      <div \n        className={`flex-1 flex flex-col overflow-hidden transition-all duration-300 ease-in-out ${\n          isMobile ? '' : isSidebarOpen ? 'ml-0' : 'ml-0'\n        }`}\n        onClick={(e) => {\n          // 在移动端点击主内容区域时关闭侧边栏\n          if (isMobile && isSidebarOpen) {\n            e.stopPropagation()\n            setIsSidebarOpen(false)\n          }\n        }}\n      >\n        {/* 顶部导航栏 */}\n        <div onClick={(e) => e.stopPropagation()}>\n          <Header\n            searchQuery={searchQuery}\n            onSearchChange={setSearchQuery}\n            searchMode={searchMode}\n            onSearchModeChange={setSearchMode}\n            onMenuClick={() => setIsSidebarOpen(!isSidebarOpen)}\n            onSearchToggle={() => setIsSearchOpen(!isSearchOpen)}\n            isSearchOpen={isSearchOpen}\n          />\n        </div>\n\n        {/* 书签网格 */}\n        <main className=\"flex-1 overflow-y-auto\">\n          <BookmarkGrid\n            spaceId={selectedSpaceId}\n            folderId={selectedFolderId}\n            searchQuery={searchMode === 'bookmarks' ? searchQuery : ''}\n          />\n        </main>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\InitModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":38,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client'\n\nimport { useState } from 'react'\nimport { useApp } from '@/contexts/AppContext'\n\ninterface InitModalProps {\n  onComplete: () => void\n}\n\nexport default function InitModal({ onComplete }: InitModalProps) {\n  const { login, t } = useApp()\n  const [username, setUsername] = useState('')\n  const [password, setPassword] = useState('admin123')\n  const [email, setEmail] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setError('')\n    setLoading(true)\n\n    try {\n      const response = await fetch('/api/auth/init', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, password, email })\n      })\n\n      const data = await response.json()\n\n      if (response.ok) {\n        login(data.token, data.user)\n        onComplete()\n      } else {\n        setError(data.error || t('initFailed'))\n      }\n    } catch (error) {\n      setError(t('initFailedRetry'))\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50\">\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6\">\n        <h2 className=\"text-2xl font-bold text-gray-900 dark:text-gray-100 mb-2\">\n          {t('init')}\n        </h2>\n        <p className=\"text-gray-600 dark:text-gray-400 mb-6\">\n          {t('initDesc')}\n        </p>\n\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n              {t('username')} *\n            </label>\n            <input\n              type=\"text\"\n              value={username}\n              onChange={(e) => setUsername(e.target.value)}\n              required\n              className=\"input-field\"\n              placeholder={t('inputUsername')}\n            />\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n              {t('password')} *\n            </label>\n            <input\n              type=\"password\"\n              value={password}\n              onChange={(e) => setPassword(e.target.value)}\n              required\n              className=\"input-field\"\n              placeholder={t('inputPassword')}\n            />\n            <p className=\"text-xs text-gray-500 mt-1\">{t('testPasswordPreset')}</p>\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n              {t('email')}\n            </label>\n            <input\n              type=\"email\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              className=\"input-field\"\n              placeholder={t('inputEmailOptional')}\n            />\n          </div>\n\n          {error && (\n            <div className=\"p-3 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-lg text-sm\">\n              {error}\n            </div>\n          )}\n\n          <button\n            type=\"submit\"\n            disabled={loading}\n            className=\"w-full btn-primary disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            {loading ? t('loading') : t('init')}\n          </button>\n        </form>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\admin\\AdminDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\admin\\BookmarkManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\admin\\FolderManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\admin\\SpaceManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\components\\ui\\CustomSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\contexts\\AppContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\auth-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\extension-auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\prisma.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\lib\\scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"I:\\Gitweb\\webooks\\tailwind.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]